- Class: meta
  Course: LiDAR for Forest Ecology
  Lesson: Lesson_2
  Author: Zack Horve
  Type: Standard
  Organization: Purdue University
  Version: 2.4.5

- Class: text
  Output: |
    Welcome to Lesson 2 of LiDAR for Forest Ecology! In this lesson, you
    will learn how identify and segment individual trees from an airborne LiDAR
    point cloud to extract tree heights and create maps of tree density across
    a forested landscape. 
    
- Class: figure
  Output: |
    For these exercises, we use a dataset from the Abby Road National Ecological 
    Observatory Network (NEON) site in Washington State. As a NEON site, Abby Road 
    is regularly surveyed by airborne remote sensing missions, including LiDAR. 
    In addition, permanent vegetation inventory plots have been established at 
    the site, where ground-based measurements are routinely collected.
  Figure: draw_ABBY_map.R
  FigureType: new
  
- Class: cmd_question
  Output: |
    Our area of interest will cover areas with different land use histories. Part
    of the area of interest was recently logged, while the other is old growth. 
    Let's load the point cloud and visualize this. Please type the following into 
    your console: 
    
    las = readLAS("ABBY_pc.laz")
    
  CorrectAnswer: las = readLAS("ABBY_pc.laz")
  AnswerTests: omnitest(correctExpr='las = readLAS("ABBY_pc.laz")')
  Hint: |
   Please type las = readLAS("ABBY_pc.laz") into your console.

- Class: cmd_question
  Output: |
    Our point cloud is now loaded into our R environment as an object called las. 
    Let's take a look at it by typing the following into your console(this will
    open a new window): 
    
    plot(las)
    
  CorrectAnswer: plot(las)
  AnswerTests: omnitest(correctExpr='plot(las)')
  Hint: |
    Please copy and paste the following into the console: 
    
    plot(las)
 
- Class: cmd_question
  Output: |
    Beyond the basic XYZ location of each LiDAR return, point clouds can store 
    many additional attributes. This particular point cloud has standardized classification
    codes for each point. These standardized classifications are defined by the 
    American Society of Photogrammetry and Remote Sensing (ASPRS) and describe the 
    type of surface from which each laser pulse reflected. Ground points are shown 
    in blue, low vegetation in white, and high vegetation in green. Let's view 
    these classifications in our point cloud. Enter the following into your console (this will open a new window): 

    plot(las, color = "Classification")

  CorrectAnswer: plot(las, color = "Classification")
  AnswerTests: omnitest(correctExpr='plot(las, color = "Classification")')
  Hint: |
    Please copy and paste the following into the console: 
    
    plot(las, color = "Classification")

- Class: text
  Output: |
    In this exercise, we move beyond ASPRS classifications to identify and segment
    individual trees from the point cloud. This is done by assigning a unique tree ID to all 
    points belonging to the same  tree. By indentifying and separating out trees from the
    point cloud, we can derive counts of trees in an area and biometrics such as heights, 
    which can be valuable for forest inventories and monitoring environmental changes 
    at broad spatial scales. 


- Class: cmd_question
  Output: |
    Before we begin tree identification and segmentation, we must first normalize 
    the point cloud. Normalization is the process of converting point heights from 
    elevations above a vertical datum to heights above the ground surface by subtracting
    a DTM from the point cloud heights. By normalizing the point cloud, we also 
    remove the influence of topography, allowing tree heights and canopy structure 
    to be compared consistently across the landscape. To normalize the point cloud, 
    enter the following into your console: 
    
    las_norm = normalize_height(las, algorithm = knnidw())
    
  CorrectAnswer: las_norm = normalize_height(las, algorithm = knnidw())
  AnswerTests: omnitest(correctExpr='las_norm = normalize_height(las, algorithm = knnidw())')
  Hint: |
    Please copy and paste the following into the console: 
    
    las_norm = normalize_height(las, algorithm = knnidw())


- Class: cmd_question
  Output: |
    Let's inspect the point cloud again. Pay close attention to the ground surface.
    You should be able to see a flat ground surface with topography removed. 
    
    Enter the following into your console (this will open a new window): 
    
    plot(las_norm)
    
  CorrectAnswer: plot(las_norm)
  AnswerTests: omnitest(correctExpr='plot(las_norm)')
  Hint: |
    Please copy and paste the following into the console: 
    
    plot(las_norm)

- Class: cmd_question
  Output: |
    We can also use the ASPRS classifications to filter the points to those that
    are high vegetation. This will ensure that only tree points will be used to 
    identify individual trees. To filter the point cloud, enter the following into 
    your console: 
    
    las_veg = filter_poi(las_norm, Classification == LASHIGHVEGETATION)
    
  CorrectAnswer: las_veg = filter_poi(las_norm, Classification == LASHIGHVEGETATION)
  AnswerTests: omnitest(correctExpr='las_veg = filter_poi(las_norm, Classification == LASHIGHVEGETATION)')
  Hint: |
    Please copy and paste the following into the console: 
    
    las_veg = filter_poi(las_norm, Classification == LASHIGHVEGETATION)

- Class: cmd_question
  Output: |
    Now that the point cloud is normalized and filtered to high vegetation, we 
    will use a local maximum filter algorithm to identify individual trees. A 
    moving window is used to locate peaks in point cloud heights, which 
    are assumed to be the tops of individual trees. In our case, we will use a 
    window size of 3 meters for simplicity. In real life applications, you can 
    experiment with different window sizes or write functions to change window size
    based on vegetation heights. Enter the following into your console: 
    
    ttops = locate_trees(las_veg, lmf(ws = 5))
    
  CorrectAnswer: ttops = locate_trees(las_veg, lmf(ws = 5))
  AnswerTests: omnitest(correctExpr='ttops = locate_trees(las_veg, lmf(ws = 5))')
  Hint: |
    Please copy and paste the following into the console: 
    
    ttops = locate_trees(las_veg, lmf(ws = 5))

- Class: mult_question
  Output: |
    How many trees did we identify using the local maximum filter? 
    
  AnswerChoices: 1288;1591;2026
  CorrectAnswer: 1288
  AnswerTests: omnitest(correctVal='1288')
  Hint: |
    Check the number of records in ttops. 

- Class: cmd_question
  Output: |
    Let's check the quality of the tree identification result by plotting the tree
    locations with the point cloud. To do so, first let's make a plot object by 
    entering the following into your console: 
    
    x = plot(las_veg, bg = "white", size = 4)
    
  CorrectAnswer: x = plot(las_veg, bg = "white", size = 4)
                 
  AnswerTests: omnitest(correctExpr='x = plot(las_veg, bg = "white", size = 4)')
  Hint: |
    Please copy and paste the following into the console: 
    
    x = plot(las_veg, bg = "white", size = 4)

- Class: cmd_question
  Output: |
    And now let's add the tree locations by entering the following into your console: 
    
    add_treetops3d(x, ttops, z = "height")

  CorrectAnswer: add_treetops3d(x, ttops, z = "height")
                 
  AnswerTests: omnitest(correctExpr='add_treetops3d(x, ttops, z = "height")')
  Hint: |
    Please copy and paste the following into the console: 
    
    add_treetops3d(x, ttops, z = "height")
    
- Class: text
  Output: |
    As shown above, the local maximum filter performs reasonably well at identifying 
    candidate tree tops. In applied settings, these results should be validated 
    using field data or compared against alternative detection algorithms, as tree 
    detection performance can vary with canopy structure, point density, and parameter 
    choices. For now, we will continue with these tree locations to perform tree segementation.
    
- Class: text
  Output: |
    Individual tree segementation is the process of assigning points within the point
    cloud to individual trees. This process is useful for deriving individual level
    tree biometrics such as tree heights. With higher resolution data from UAV or 
    terrestrial LiDAR systems, more detailed biometrics can be measured such as the
    diameter at breast height (DBH) or volumes of individual trees. 
    
- Class: text
  Output: |
    In this dataset, point density is relatively low, which limits the range of 
    tree-level metrics that can be reliably estimated. In practice, tree height 
    is the primary metric that can be robustly derived, and this was already obtained 
    during the tree detection step.
    
    For the sake of demonstration, we will proceed with individual tree segmentation 
    as it illustrates a critical step of most forest LiDAR analysis workflows. 

- Class: cmd_question
  Output: |
    To perform individual tree segmentation, we will use an algorithm developed by
    Dalponte & Coomes 2016 (https://doi.org/10.1111/2041-210X.12575) that utilizes 
    a canopy height model along with tree locations to segement the point cloud. 
    To start, let's load in the CHM for this area. Enter the following into your console:
    
    chm = rast("ABBY_chm.tif")
    
  CorrectAnswer: chm = rast("ABBY_chm.tif")
                 
  AnswerTests: omnitest(correctExpr='chm = rast("ABBY_chm.tif")')
  Hint: |
    Please copy and paste the following into the console: 
    
    chm = rast("ABBY_chm.tif")
    
- Class: cmd_question
  Output: |
    Now let's apply the segmentation algorithm. Enter the following into your console: 
    
    seg = segment_trees(las_veg, dalponte2016(chm, ttops), attribute = "treeID") 
    
  CorrectAnswer: seg = segment_trees(las_veg, dalponte2016(chm, ttops), attribute = "treeID")
                 
  AnswerTests: omnitest(correctExpr='seg = segment_trees(las_veg, dalponte2016(chm, ttops), attribute = "treeID")')
  Hint: |
    Please copy and paste the following into the console: 
    
    seg = segment_trees(las_veg, dalponte2016(chm, ttops), attribute = "treeID") 

- Class: cmd_question
  Output: |
    Let's investigate these segementation results by finding the tallest tree
    in this area and viewing it by itself. First, we need to determine which tree
    is the tallest by looking into ttops. Open the ttops dataframe by entering the
    following into your console: 
    
    View(ttops)
    
  CorrectAnswer: View(ttops)
                 
  AnswerTests: omnitest(correctExpr='View(ttops)')
  Hint: |
    Please copy and paste the following into the console: 
    
    View(ttops)
    
- Class: mult_question
  Output: |
    What is the height of the tallest tree? Note, you can sort the records by 
    height by clickign on the Z column label.
    
  AnswerChoices: 56.184 m;53.221 m;45.987 m
  CorrectAnswer: 56.184 m
  AnswerTests: omnitest(correctVal='56.184 m')
  Hint: |
    Sort using the Z column label.
    
- Class: cmd_question
  Output: |
    Returning to the ttops dataframe, find the treeID of the tallest tree. We will 
    use that treeID to filter the point cloud to points belonging only to that tree.
    To do so, replace TALLEST_ID in the code below with the correct treeID and enter it
    into your console:
    
    tallest = filter_poi(seg, treeID == TALLEST_ID)
    
  CorrectAnswer: tallest = filter_poi(seg, treeID == 1249)
                 
  AnswerTests: omnitest(correctExpr='tallest = filter_poi(seg, treeID == 1249)')
  Hint: |
    Make sure you are checking the treeID column of the ttops record with the largest
    Z value. 
    
- Class: cmd_question
  Output: |
    Now that we have filtered the point cloud to only points with the same treeID
    as the tallest tree, let's view the resulting point cloud. Enter the following 
    into your console: 
    
    plot(tallest)
    
  CorrectAnswer: plot(tallest)
                 
  AnswerTests: omnitest(correctExpr='plot(tallest)')
  Hint: |
    Please enter the following into your console: 
    
    plot(tallest)
    
- Class: cmd_question
  Output: |
    We can also use the treeID codes assigned to each point in the point cloud to
    highlight the tallest tree in a plot along with all of the other trees. To do 
    so, we will use a custom plotting function that has already been loaded (if
    you would like to look into the details, check the initLesson.R for this 
    lesson). Enter the following your console: 
    
    highlight_tree(seg, 1249)
    
  CorrectAnswer: highlight_tree(seg, 1249)
                 
  AnswerTests: omnitest(correctExpr='highlight_tree(seg, 1249)')
  Hint: |
    Please enter the following into your console: 
    
    highlight_tree(seg, 1249)

- Class: cmd_question
  Output: |
    As mentioned earlier, the point density of this dataset is too low to derive
    many metrics beyond tree height. However, we can still use the locations of 
    the trees we identified to create useful maps. For the last portion of this 
    exercise, we will create maps of tree density and height. To start, we need to
    create an empty raster object with the same extent as the point cloud. Enter
    the following into your console to get the extent of the point cloud: 
    
    seg_ext = ext(seg)
    
  CorrectAnswer: seg_ext = ext(seg)
                 
  AnswerTests: omnitest(correctExpr='seg_ext = ext(seg)')
  Hint: |
    Please enter the following into your console: 
    
    seg_ext = ext(seg)
    
- Class: cmd_question
  Output: |
    Next, we will create the empty raster object. We will set the resolution of the
    raster to 20 meters for simplicity. In real life applications, the appropriate
    resolution may vary. Enter the following into your console:  
    
    r = rast(ext = seg_ext, resolution = 20,crs = st_crs(ttops)$wkt)

  CorrectAnswer: r = rast(ext = seg_ext, resolution = 20,crs = st_crs(ttops)$wkt)
                 
  AnswerTests: omnitest(correctExpr='r = rast(ext = seg_ext, resolution = 20,crs = st_crs(ttops)$wkt)')
  Hint: |
    Please enter the following into your console: 
    
    r = rast(ext = seg_ext, resolution = 20,crs = st_crs(ttops)$wkt)

- Class: cmd_question
  Output: |
    Now we will create a map showing the number of trees per 20 meter cell. This 
    is done using our ttops object which contains the XY location of each tree 
    we identified. 
    
    n_trees_rast = rasterize(vect(ttops), r, field = "treeID", fun = "count")

  CorrectAnswer: n_trees_rast = rasterize(vect(ttops), r, field = "treeID", fun = "count")
                 
  AnswerTests: omnitest(correctExpr='n_trees_rast = rasterize(vect(ttops), r, field = "treeID", fun = "count")')
  Hint: |
    Please enter the following into your console: 
    
    n_trees_rast = rasterize(vect(ttops), r, field = "treeID", fun = "count")

- Class: cmd_question
  Output: |
    Since each raster cell represents a fixed area, tree density can be calculated 
    by dividing the number of trees in a cell by its area (400 m^2). This gives density in 
    trees per square meter. To express results in a more interpretable and widely 
    used unit, we multiply by 10^4 to convert densities to trees per hectare.
    
    tree_density_ha = n_trees_rast / 400 * 1e4

  CorrectAnswer: tree_density_ha = n_trees_rast / 400 * 1e4
                 
  AnswerTests: omnitest(correctExpr='tree_density_ha = n_trees_rast / 400 * 1e4')
  Hint: |
    Please enter the following into your console: 
    
    tree_density_ha = n_trees_rast / 400 * 1e4
    
- Class: cmd_question
  Output: |
    Now let's view our map of tree density. Enter the following into your console: 
    
    plot(tree_density_ha, main = "Tree Density (trees / ha)")

  CorrectAnswer: plot(tree_density_ha, main = "Tree Density (trees / ha)")
                 
  AnswerTests: omnitest(correctExpr='plot(tree_density_ha, main = "Tree Density (trees / ha)")')
  Hint: |
    Please enter the following into your console: 
    
    plot(tree_density_ha, main = "Tree Density (trees / ha)")
    
- Class: cmd_question
  Output: |
    Similarly, we can use our template raster and ttops object to make a map of 
    average tree height. Try this on your own, using our code from the tree count
    map as a reference. Use Z as the field and mean as the function. Name the raster
    mean_ht_rast.
    
  CorrectAnswer:  mean_ht_rast = rasterize(vect(ttops), r, field = "Z", fun = "mean")
                 
  AnswerTests: omnitest(correctExpr=' mean_ht_rast = rasterize(vect(ttops), r, field = "Z", fun = "mean")')
  Hint: |
    Here is the example code from the tree count raster:
    
    n_trees_rast = rasterize(vect(ttops), r, field = "treeID", fun = "count")
    
    To create the mean height raster, you must change the name of the object (n_trees_rast),
    the field (currently "treeID"), and function (currently "count"). 
    
- Class: cmd_question
  Output: |
    Now that we have the map of mean tree height, let's view it! Enter the following 
    into your console: 
    
    plot(mean_ht_rast, main = "Mean Tree Height per 20 m")

  CorrectAnswer: plot(mean_ht_rast, main = "Mean Tree Height per 20 m")
                 
  AnswerTests: omnitest(correctExpr='plot(mean_ht_rast, main = "Mean Tree Height per 20 m")')
  Hint: |
    Please enter the following into your console: 
    
    plot(mean_ht_rast, main = "Mean Tree Height per 20 m")

